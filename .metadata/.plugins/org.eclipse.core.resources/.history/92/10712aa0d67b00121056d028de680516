package edu.kcg.Poker;

import java.util.ArrayList;
import java.util.Vector;

import edu.kcg.Poker.Factory.TableFactory;
import edu.kcg.Poker.Strategy.AdaptStrategy;
import edu.kcg.Poker.View.PokerView;

/**
 * テーブルのデータを処理し、ゲームを定義するクラス.
 * 
 * @author Shun.S
 * 
 */
public class PokerGame extends TableFactory implements GameRules,Runnable {
	
	public PokerGame() {
		createTable();
	}

	public PokerGame(PokerView view) {
		createTable(view);
	}

	public void addPlayer(Player player) {
		table.addChair(player);
	}

	@Override
	public void chancePhase() {

		int countFold = countFold();
		int countAllin = countAllin();
		int chairSize = table.chairSize();
		int notFolder = chairSize - countFold;
		int round = updateRound(table.getRound());

		dealCommunityCard(round);

		/****************************/
		view.communityCardStatus();
		/*****************************/

		if (notFolder == 1 || (notFolder - countAllin) < 2) {
			if (table.getRound() == 4) {
				return;
			}
			chancePhase();
		}
	}

	@Override
	public void execute() {
		int status;
		initGame();

		while (true) {
			status = gameStatus();

			/******************/
			view.phaseStatus(status);
			/******************/

			gameGraph(status);

			if (table.chairSize() == 1) {
				break;
			}

			nextPhase();

			/**************/
			view.phaseLast();
			/**************/
		}
	}

	@Override
	public void finalPhase() {

		divisionProfit();

		/***************/
		view.communityCardStatus();
		/***************/

		// firstフェーズに戻るためにポットを初期化。
		table.setPot(0);
	}

	@Override
	public void firstPhase() {
		int[] blind = decideBlind();
		int small = blind[0];
		int big = blind[1];
		payBlind(small, big);
	}

	@Override
	public int gameStatus() {

		if (isFirst()) {
			return GameRules.FIRST;
		}

		if (isFinal()) {
			return GameRules.FINAL;
		}

		if (isHuman()) {
			return GameRules.HUMAN;
		}

		if (updateChance()) {
			return GameRules.CHANCE;
		}

		// それ以外は偶然手番。
		return GameRules.CHANCE;
	}

	public Table getTable() {
		return table;
	}

	@Override
	public void humanPhase() {

		int index = table.getCurrentPlayer();
		int maxBet = table.getMaxRaise();
		int limit = table.getLimit();
		Chair chair = table.getChairs().get(index);
		int pastBankroll = chair.getBankroll();

		if (pastBankroll == 0) {
			chair.setAllin(true);
		}

		/******************/
		view.playerStatus(index);
		/******************/

		if (!chair.isFold()) {
			int option = 0;
			int chairSize = table.chairSize();
			int countFold = countFold();
			int notFolder = chairSize - countFold;
			int countAllin = countAllin();

			// プレイヤーが戦略で使えるパラメータを渡し、選択肢を選択させる。
			if ((notFolder > 1) && (notFolder - countAllin != 0)) {
				AdaptStrategy strategy = (AdaptStrategy) chair.getPlayer()
						.getStrategy();
				strategy.setParams(table.packParams(index));
				option = chair.choice(maxBet, limit);
			}

			// 選択肢がフォルドでないなら上乗せ分をポットに加算。
			if (option > -1) {
				int bet = option + maxBet;
				if (pastBankroll < bet) {
					bet = pastBankroll + chair.getCurrentRaise();
				}
				table.setMaxRaise(bet);
				addPot(bet - chair.getCurrentRaise());
				chair.setCurrentRaise(bet);
			}
		}
		/****************************/
		view.lastPlayStatus(index);
		/****************************/
	}

	@Override
	public int nextPhase() {
		int currentPhase = this.gameStatus();
		updateCurrentPlayer(currentPhase);
		table.setCurrentPhase(currentPhase);
		return currentPhase;
	}

	@Override
	public void run() {
		execute();
	}

	public void setTable(Table table) {
		this.table = table;
	}

	/**
	 * ポットを加算
	 * 
	 * @param x
	 */
	private void addPot(int x) {
		table.addPot(x);
	}

	private int backOverRaise(int maxAddedBet,boolean[] winners) {
		ArrayList<Chair> chairs = table.getChairs();
		int pot = table.getPot();
		// 勝者よりも掛け金が多い敗北プレイヤーに過多分の返上。
		for (int i=0;i<chairs.size();i++) {
			Chair chair = chairs.get(i);
			if (winners[i]) {
				int x = chair.getAddedBet();
				if (x > maxAddedBet) {
					x = chair.getAddedBet() - maxAddedBet;
					pot -= x;
					chair.profit(x);
				}
			}
		}
		return pot;
	}

	private void chairsInit() {
		for (Chair chair : table.getChairs()) {
			chair.setLastPlay(0);
			chair.setAllin(false);
			chair.setFold(false);
//			chair.setHand(0);
			chair.setHands(0);
//			chair.setWinner(false);
			chair.setAddedBet(0);
		}
	}

	private int countAllin() {
		int count = 0;
		for (Chair chair : this.table.getChairs()) {
			if (chair.getBankroll() == 0/* isallin */) {
				count++;
			}
		}
		return count;
	}

	private int countFold() {
		int count = 0;
		for (Chair chair : this.table.getChairs()) {
			if (chair.isFold()) {
				count++;
			}
		}
		return count;
	}

	/**
	 * カードを配る。
	 */
	private void deal() {
		for (Chair chair : table.getChairs()) {
			int cardLeft = table.popDeck() << 6;
			int cardRight = table.popDeck();
			int hands = (cardLeft | cardRight);
			chair.setHands(hands);
		}
	}

	/**
	 * コミュニティカードを配る。
	 * 
	 * @param round
	 */
	private void dealCommunityCard(int round) {
		// ラウンド1ならデックからコミュニティカードに3枚出す。
		// ラウンド2,3なら、デックからコミュニティカードに1枚出す。
		// ラウンド4なら何もしない。
		if (round == 1) {
			for (int i = 0; i < 3; i++) {
				int card = table.popDeck();
				table.pushCommunityCards(card);
			}
		} else if (round == 2 || round == 3) {
			int card = table.popDeck();
			table.pushCommunityCards(card);
		} else if (round == 4) {
		}
	}

	private int[] decideBlind() {
		int[] blind = new int[2];

		// スモールブラインドを決定する。
		int small = table.getDealer() + 1;
		if (small > table.chairSize() - 1) {
			small = 0;
		}
		// ビッグブラインドを決定する。
		int big = small + 1;
		if (big > table.chairSize() - 1) {
			big = 0;
		}
		blind[0] = small;
		blind[1] = big;

		return blind;
	}

	/**
	 * 利益の分配。
	 */
	private void divisionProfit() {

		int maxAddedBet = 0;
		int sumWinner = 0;
		int max = 0;
		int pot = 0;
		int chairSize = table.chairSize();
		int[] handrolls = new int[chairSize]; 
		boolean[] winners = new boolean[chairSize];
		
		handrolls = solveHandrolls();
		max = solveMaxHandroll(handrolls);
		winners = solveWinner(max,handrolls);
		sumWinner = solveSumWinnersBet(winners);
		maxAddedBet = solveMaxAddedBet(winners);
		pot = backOverRaise(maxAddedBet,winners);
		solveProfit(pot, sumWinner, winners);

	}

	private void finalize(int status) {
		if (status == GameRules.FINAL) {
			initGame();
		}
	}
	
	private void gameGraph(int status) {
		switch (status) {
		case GameRules.FIRST:
			firstPhase();
			break;
		case GameRules.HUMAN:
			humanPhase();
			break;
		case GameRules.CHANCE:
			chancePhase();
			break;
		case GameRules.FINAL:
			finalPhase();
			break;
		}
		finalize(status);
	}

	private void initGame() {
		updateChairs();
		chairsInit();
		tableInit();
		shuffle();
		deal();
		nextDealer();
	}

	private boolean isFinal() {
		if (table.getRound() == 4) {
			return true;
		}

		return false;
	}

	private boolean isFirst() {
		if (table.getPot() == 0) {
			return true;
		}

		return false;
	}

	private boolean isHuman() {
		ArrayList<Chair> chairs = table.getChairs();
		// あるプレイヤーがオールインもフォルドもしていない場合、
		// 全員の掛け金の最大と同じ額を賭けていなければ人為手番。
		// または、最終プレイの値がIntegerの最小値になっていたら人為手番。
		for (Chair chair : chairs) {
			boolean b1 = chair.getCurrentRaise() != table.getMaxRaise();
			boolean b2 = !(chair.isAllin() || chair.isFold());
			boolean b3 = chair.getLastPlay() == Integer.MIN_VALUE;
			if (b1 && b2 || b3) {
				return true;
			}
		}
		return false;
	}

	/**
	 * 次のディーラーを決定。
	 */
	private void nextDealer() {
		int dealer = table.getDealer();
		int playerNum = table.chairSize();
		dealer++;
		if (dealer > playerNum - 1) {
			dealer = 0;
		}
		table.setDealer(dealer);
	}

	private void payBlind(int small, int big) {
		int anty = table.getAnty();
		ArrayList<Chair> chairs = table.getChairs();

		// スモールブラインドにアンティを支払わせる。
		Chair smallblind = chairs.get(small);
		smallblind.payAnty(anty);

		// ビッグブラインドにアンティを支払わせる。
		Chair bigblind = chairs.get(big);
		bigblind.payAnty(anty * 2);

		// ポットにアンティを支払い分を追加。
		addPot(anty * 3);

		// レイズの最大値と現在手番のプレイヤーを更新。
		table.setMaxRaise(anty * 2);
		table.setCurrentPlayer(big);
	}

	/**
	 * デックをシャッフル
	 */
	private void shuffle() {
		int[] bufDeck = new int[52];
		for (int i = 0; i < bufDeck.length; i++) {
			bufDeck[i] = i;
		}

		for (int i = bufDeck.length - 1; i > 0; i--) {
			int t = (int) (Math.random() * i);
			int tmp = bufDeck[i];
			bufDeck[i] = bufDeck[t];
			bufDeck[t] = tmp;
		}

		table.setDeck(bufDeck);
	}

	private int[] solveHandrolls() {
		int handroll = 0;
//		int max = 0;
		ArrayList<Chair> chairs = table.getChairs();
		int[] handrolls = new int[chairs.size()];

		// 最大ハンドを計算。
		for (int i=0;i<chairs.size();i++) {
			// ハンドを取得
			Chair chair = chairs.get(i);
			int hands = chair.getHands();
			handroll = 0;
			int[] comcard = table.getCommunityCards();
			// 役の強さを計算。
			if (!chair.isFold()) {
				handroll = HandChecker.checkHand(hands, comcard);
			}
			
			handrolls[i] = handroll;
			
/*		chair.setHand(hand);
			// 最大ハンドより大きければ、
			if (handroll >= max) {
				max = handroll;
			}
*/
			/***************/
			view.playerHands(i);
			/***************/

		}
		return handrolls;
	}

	private int solveMaxAddedBet(boolean[] winners) {
		int maxAddedBet = 0;
		ArrayList<Chair> chairs = table.getChairs();
		int chairSize = table.chairSize();
		// 勝者の掛け金の最大を計算。
		for (int i = 0; i < chairSize; i++) {
			Chair chair = chairs.get(i);
			if (winners[i]) {
				int x = chair.getAddedBet();
				if (x > maxAddedBet) {
					maxAddedBet = x;
				}
			}
		}
		return maxAddedBet;
	}

	private int solveMaxHandroll(int[] handrolls){
		int max = 0;

		// 最大ハンドを計算
		for (int i=0;i<handrolls.length;i++) {
			// 最大ハンドより大きければ、
			if (handrolls[i] >= max) {
				max = handrolls[i];
			}
		}
		return max;
	}

	private void solveProfit(int pot, int sumWinner ,boolean[] winners) {
		ArrayList<Chair> chairs = table.getChairs();
		int chairSize = chairs.size();
		// 勝者に利益を配分。
		// ある勝者の合計掛け金をxとすると、x/sumWinnerが分配される。
		for (int i=0;i<chairSize;i++) {
			Chair chair = chairs.get(i);
			if (winners[i]) {
				int x = chair.getAddedBet();
				int profit = (x * pot) / sumWinner;
				chair.profit(profit);
			}
			/*****/
			view.playerBankroll(i);
			/*****/
		}
	}

	private int solveSumWinnersBet(boolean[] winners){
		int sumWinner = 0;
		ArrayList<Chair> chairs = table.getChairs();
		int chairSize = chairs.size();
		for(int i=0;i<chairSize;i++){
			if(winners[i]){
				sumWinner+= chairs.get(i).getAddedBet();
			}
		}
		return sumWinner;
	}
	
	private boolean[] solveWinner(int max,int[] handRoll){
//		int sumWinner = 0;
		ArrayList<Chair> chairs = table.getChairs();
		int chairSize = chairs.size();
		// 勝者を決定。
		boolean[] winner = new boolean[chairSize];
		for (int i=0;i<winner.length;i++) {
//			if (chair.getHand() == max) {
//				chair.setWinner(true);
			if(handRoll[i] == max){
				winner[i] = true;
				//sumWinner += chair.getAddedBet();
			}else{
				winner[i] = false;
			}
		}
		return winner;
//		return sumWinner;
	}

	private void tableInit() {
		int[] comcard = new int[5];
		for (int i = 0; i < comcard.length; i++) {
			comcard[i] = -1;
		}
		table.setMaxRaise(0);
		table.setRound(0);
		table.setCommunityCardsIndex(0);
		table.setCommunityCards(comcard);
		table.setDeckIndex(51);
		table.setPot(0);
	}

	private void updateChairs() {
		ArrayList<Chair> chairs = this.table.getChairs();
		Vector<Chair> buffer = new Vector<Chair>();

		for (Chair chair : chairs) {
			if (chair.getBankroll() < table.getAnty() * 2) {
				buffer.add(chair);
			}
		}

		for (Chair removeItem : buffer) {
			chairs.remove(removeItem);
		}

	}

	private boolean updateChance() {
		// 現在手番が偶然手番の時の処理。
		if (table.getCurrentPhase() == GameRules.CHANCE) {
			// 現在手番を人為手番に設定。
			table.setCurrentPhase(GameRules.HUMAN);
			// フォルドしていないかオールインしていない場合、
			// 最終プレイの値をIntegerの最小値に設定する。
			for (Chair chair : table.getChairs()) {
				if (!(chair.isFold() || chair.isAllin())) {
					chair.setLastPlay(Integer.MIN_VALUE);
				}
			}
			// 形式的に偶然手番をリターンする。
			return true;
		}
		return false;
	}

	private void updateCurrentPlayer(int currentPhase) {
		int currentPlayer = table.getCurrentPlayer();
		int playerNum = table.chairSize();
		if (currentPhase == GameRules.HUMAN || currentPhase == GameRules.FIRST) {
			currentPlayer++;
			if (currentPlayer > playerNum - 1) {
				currentPlayer = 0;
			}
		} else {
			currentPlayer = table.getDealer();
		}
		table.setCurrentPlayer(currentPlayer);
	}

	private int updateRound(int round) {
		++round;
		table.setRound(round);
		table.setMaxRaise(0);
		for (Chair chair : table.getChairs()) {
			chair.setCurrentRaise(0);
		}
		return round;
	}
}
